<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jürgen van Wessel - Executive Portfolio</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath fill='%236B5442' d='M50 5 L90 28 L90 72 L50 95 L10 72 L10 28 Z'/%3E%3C/svg%3E">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>
    <script defer src="https://cloud.umami.is/script.js" data-website-id="b74eba8e-b2c5-4738-bf7b-b59d5d250dcf"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #E8D4A2;
            color: #5C4A3A;
            padding: 60px 80px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .nav-wrapper {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 30px;
            padding-bottom: 5px;
            margin-bottom: 40px;
            border-bottom: 1px solid rgba(92, 74, 58, 0.2);
            position: relative;
        }

        .nav-wrapper.hidden {
            display: none;
        }

        .page-wrapper {
            display: grid;
            grid-template-columns: 1fr 35%;
            gap: 60px;
            align-items: start;
        }

        .content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .text-section {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .profile {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            text-decoration: none;
            color: inherit;
            transition: opacity 0.2s;
        }

        .profile:hover {
            opacity: 0.8;
        }

        .profile-image {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            object-position: 35% center;
            border: 4px solid #6B5442;
            background: #E8D4A2;
            padding: 1px;
            box-sizing: border-box;
            position: relative;
            z-index: 10;
            margin-bottom: -25px;
            box-shadow: 0 0 0 12px #E8D4A2;
        }

        .profile-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: #5C4A3A;
            letter-spacing: 0.5px;
        }

        .nav-container {
            display: flex;
            align-items: baseline;
            gap: 20px;
            margin-bottom: 25px;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            flex: 1;
        }

        .nav-link {
            color: #5C4A3A;
            text-decoration: none;
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: rgba(92, 74, 58, 0.1);
        }

        .nav-link.active {
            background: rgba(92, 74, 58, 0.15);
            font-weight: 600;
        }

        .nav-link.disabled {
            color: #B8A896;
            cursor: help;
            font-style: italic;
            position: relative;
        }

        .nav-link.disabled:hover {
            background: transparent;
        }

        .nav-link.disabled:hover .nav-tooltip {
            opacity: 1;
        }

        .nav-tooltip {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(107, 84, 66, 0.95);
            color: #E8D4A2;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 0.75rem;
            line-height: 1.5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 3000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 250px;
            max-width: 300px;
            white-space: normal;
            font-style: normal;
        }

        .nav-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(107, 84, 66, 0.95);
        }

        .icon-links {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .icon-link {
            color: #6B5442;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            padding: 4px;
        }

        .icon-link:hover {
            color: #B8342E;
            transform: translateY(-1px);
        }

        .resume-link {
            color: #6B5442;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
            white-space: nowrap;
        }

        .resume-link:hover {
            color: #B8342E;
        }

        .icon-link svg {
            width: 22px;
            height: 22px;
        }

        /* Inline text links */
        .description a,
        .details-content a {
            color: #B8342E;
            text-decoration: none;
            border-bottom: 1px solid rgba(184, 52, 46, 0.3);
            transition: all 0.2s;
        }

        .description a:hover,
        .details-content a:hover {
            border-bottom-color: #B8342E;
        }

        .linkedin-link {
            margin-left: auto;
            color: #6B5442;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            padding: 4px;
        }

        .linkedin-link:hover {
            color: #B8342E;
            transform: translateY(-1px);
        }

        .linkedin-link svg {
            width: 24px;
            height: 24px;
        }

        .case-study {
            display: none;
        }

        .case-study.active {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        /* LANDING PAGE STYLES */
        .landing-page {
            display: none;
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .landing-page.active {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }

        .landing-hero {
            display: grid;
            grid-template-columns: 1fr 35%;
            gap: 60px;
            align-items: start;
            width: 100%;
            max-width: 1800px;
        }

        .landing-content {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 100%;
        }

        .landing-portrait {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            display: block;
            background: transparent;
        }

        .landing-availability {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-top: 20px;
        }

        .availability-text {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #6B5442;
        }

        .availability-contact {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .availability-icon-link {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6B5442;
            transition: all 0.2s;
            border: 2px solid #6B5442;
            border-radius: 6px;
            padding: 6px;
        }

        .availability-icon-link:hover {
            color: #B8342E;
            border-color: #B8342E;
            transform: translateY(-2px);
        }

        .availability-icon-link svg {
            width: 100%;
            height: 100%;
        }

        .availability-resume-link {
            color: #6B5442;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
            white-space: nowrap;
        }

        .availability-resume-link:hover {
            color: #B8342E;
        }

        .availability-roles {
            font-size: 0.85rem;
            line-height: 1.6;
            color: #8B7355;
            font-style: italic;
        }

        .availability-roles strong {
            color: #6B5442;
            font-style: normal;
        }

        .landing-intro {
            max-width: none;
            text-align: left;
            position: relative;
        }

        .landing-intro h1 {
            font-size: 2.8rem;
            line-height: 1.3;
            margin-bottom: 25px;
            color: #5C4A3A;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .landing-intro h1::before {
            content: '';
            width: 24px;
            height: 27.7px;
            background: #B8342E;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            position: absolute;
            left: -54px;
            top: 15px;
        }

        .landing-intro p {
            font-size: 1.5rem;
            line-height: 1.5;
            color: #6B5442;
            margin-bottom: 20px;
            font-weight: 400;
        }

        .landing-intro .landing-tagline {
            font-size: 1.5rem;
            line-height: 1.5;
            color: #6B5442;
            font-weight: 400;
            margin-bottom: 20px;
        }

        .landing-intro .landing-cta {
            font-size: 1.5rem;
            line-height: 1.5;
            color: #B8342E;
            font-weight: 400;
            margin-bottom: 20px;
        }

        .landing-intro .landing-examples {
            font-size: 1.5rem;
            line-height: 1.5;
            color: #6B5442;
            font-weight: 400;
            margin-bottom: 30px;
        }

        .case-study-cards {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
        }

        .case-study-card {
            background: transparent;
            border: 2px solid #6B5442;
            border-radius: 10px;
            padding: 24px 32px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            color: inherit;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .case-study-card:hover {
            background: rgba(184, 52, 46, 0.08);
            border-color: #B8342E;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }

        .case-study-card-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #5C4A3A;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .case-study-card-subtitle {
            font-size: 0.85rem;
            color: #B8342E;
            letter-spacing: 1px;
        }

        .case-study-card-description {
            font-size: 0.9rem;
            color: #6B5442;
            line-height: 1.4;
        }

        h1 {
            font-size: 2rem;
            line-height: 1.3;
            margin-bottom: 20px;
            color: #5C4A3A;
            font-weight: 400;
        }

        .subheading {
            font-size: 1rem;
            color: #B8342E;
            letter-spacing: 2px;
            font-weight: 400;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subheading-hex {
            width: 10.39px;
            height: 12px;
            background: #B8342E;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            flex-shrink: 0;
        }

        .description {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #5C4A3A;
        }

        .description p {
            margin-bottom: 12px;
        }

        .stats {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            font-size: 0.85rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-number {
            font-size: 1.5rem;
            color: #B8342E;
            font-weight: 600;
            white-space: nowrap;
        }

        .stat-label {
            color: #8B7355;
            letter-spacing: 0.5px;
        }

        .details {
            margin-top: 20px;
            border-left: 2px solid #B8342E;
            padding-left: 15px;
        }

        .details-toggle {
            color: #B8342E;
            cursor: pointer;
            font-size: 0.9rem;
            letter-spacing: 1px;
            margin-bottom: 10px;
            user-select: none;
        }

        .details-toggle:hover {
            color: #8B2822;
        }

        .details-toggle::before {
            content: '▸ ';
            display: inline-block;
            transition: transform 0.2s;
        }

        .details-toggle.open::before {
            transform: rotate(90deg);
        }

        .details-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: #6B5442;
            display: none;
            margin-top: 10px;
        }

        .details-content.open {
            display: block;
        }

        .details-content p {
            margin-bottom: 10px;
        }

        .image-placeholder {
            width: 100%;
            max-width: 500px;
            height: auto;
            margin-top: 30px;
        }

        .project-image {
            width: 100%;
            height: auto;
            display: block;
        }

        /* MAP */
        .hero {
            position: sticky;
            top: 0;
            align-self: start;
        }

        .map-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #map.debug-visible {
            opacity: 1;
        }

        #canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: all;
            z-index: 1000;
            transition: opacity 0.2s ease;
        }

        .leaflet-control-attribution {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .leaflet-control-attribution.debug-visible {
            opacity: 1;
        }

        /* DEBUG */
        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(107, 84, 66, 0.9);
            color: #E8D4A2;
            padding: 10px;
            font-size: 12px;
            max-width: 300px;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .debug-info.visible {
            opacity: 1;
        }

        /* KEYMAP TOOLTIP */
        .keymap-tooltip {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(107, 84, 66, 0.95);
            color: #E8D4A2;
            padding: 15px 20px;
            border-radius: 6px;
            font-size: 0.75rem;
            line-height: 1.6;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 3000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 200px;
        }

        .keymap-tooltip.visible {
            opacity: 1;
        }

        .keymap-mobile-message {
            display: none;
            text-align: center;
            font-style: italic;
        }

        .keymap-section {
            margin-bottom: 10px;
        }

        .keymap-section:last-child {
            margin-bottom: 0;
        }

        .keymap-title {
            font-weight: 600;
            color: #B8342E;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
        }

        .keymap-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
        }

        .keymap-key {
            background: rgba(232, 212, 162, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            margin-right: 8px;
            border: 1px solid rgba(232, 212, 162, 0.3);
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .keymap-key:hover,
        .keymap-key:active {
            background: rgba(232, 212, 162, 0.4);
            border-color: rgba(232, 212, 162, 0.6);
            transform: translateY(-1px);
        }

        .keymap-action {
            flex: 1;
            text-align: right;
        }

        /* GIS MODAL */
        .gis-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(92, 74, 58, 0.95);
            z-index: 5000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .gis-modal-overlay.visible {
            display: flex;
        }

        .gis-modal {
            background: #E8D4A2;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .gis-modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            color: #5C4A3A;
            cursor: pointer;
            padding: 5px 10px;
        }

        .gis-modal-close:hover {
            color: #B8342E;
        }

        .gis-modal h2 {
            color: #B8342E;
            font-size: 1.8rem;
            margin-bottom: 20px;
            font-weight: 400;
        }

        .gis-modal h3 {
            color: #5C4A3A;
            font-size: 1.2rem;
            margin-top: 25px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .gis-modal p {
            line-height: 1.7;
            margin-bottom: 15px;
            color: #5C4A3A;
        }

        .gis-modal code {
            background: #D4C4A4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .gis-modal::-webkit-scrollbar {
            width: 8px;
        }

        .gis-modal::-webkit-scrollbar-track {
            background: #D4C4A4;
        }

        .gis-modal::-webkit-scrollbar-thumb {
            background: #8B7355;
            border-radius: 4px;
        }

        /* RESPONSIVE */
        @media (max-width: 900px) {
            body {
                padding: 30px 20px;
            }

            .nav-wrapper {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
                padding-bottom: 25px;
            }

            .profile-image {
                margin-bottom: 0;
            }

            .profile-name {
                font-weight: 700;
            }

            .keymap-section {
                display: none;
            }

            .keymap-mobile-message {
                display: block;
            }

            .page-wrapper {
                grid-template-columns: 1fr;
                gap: 30px;
            }

            .map-container {
                height: 500px;
                max-height: 60vh;
            }

            h1 {
                font-size: 1.5rem;
            }

            /* Landing page mobile styles */
            .landing-intro {
                text-align: left;
                margin-left: 30px; /* Space for red hex */
                margin-right: 0;
            }

            .landing-intro h1 {
                font-size: 1.6rem;
                margin-bottom: 20px;
            }

            .landing-intro h1::before {
                left: -30px; /* Position hex in left margin */
                top: 8px;
                width: 18px;
                height: 20.8px;
            }

            .landing-intro .landing-tagline,
            .landing-intro .landing-cta,
            .landing-intro .landing-examples {
                font-size: 1rem;
                margin-bottom: 15px;
            }

            .landing-hero {
                grid-template-columns: 1fr;
                gap: 30px;
            }

            .landing-content {
                gap: 25px;
            }

            .landing-portrait {
                width: 180px;
                height: 180px;
                justify-self: center;
                margin: 0 auto;
            }

            .case-study-card {
                padding: 20px 24px;
            }
        }
    </style>
</head>
<body>
    <!-- NAVIGATION BAR -->
    <div class="nav-wrapper" id="navWrapper">
        <a href="#landing" class="profile" id="profileLink">
            <img src="profile_avatar.png" alt="Jürgen van Wessel" class="profile-image">
            <div class="profile-name">Jürgen van Wessel</div>
        </a>
        <div class="nav-links">
            <a href="#product-ownership" class="nav-link" data-case="product-ownership">Innovation at Scale</a>
            <a href="#geospatial-recovery" class="nav-link" data-case="geospatial-recovery">Geospatial Leadership</a>
            <a href="#digital-delivery" class="nav-link" data-case="digital-delivery">Digital Delivery</a>
        </div>
        <div class="icon-links">
            <a href="/cdn-cgi/l/email-protection#9cf6e9eefbf9f2eafdf2ebf9efeff9f0dcf3e9e8f0f3f3f7b2fff3f1" class="icon-link" title="Email: jurgenvanwessel@outlook.com">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
                    <polyline points="22,6 12,13 2,6"/>
                </svg>
            </a>
            <a href="https://linkedin.com/in/jurgenvanwessel" target="_blank" rel="noopener" class="icon-link" title="LinkedIn Profile">
                <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                </svg>
            </a>
            <a href="mailto:jurgenvanwessel@outlook.com?subject=Portfolio%20resume%20request" class="resume-link" title="Request Resume">
                Resume on request
            </a>
        </div>
    </div>

    <!-- LANDING PAGE -->
    <div class="landing-page" id="landing-page">
        <div class="landing-hero">
            <div class="landing-content">
                <div class="landing-intro">
                    <h1>I am Jürgen van Wessel</h1>
                    <p class="landing-tagline">Ambitious organizations hire me to transform their geospatial and digital delivery operations. I build strong technical teams, modernize platforms and processes, and drive innovation so they can scale faster and compete more effectively.</p>
                    <p class="landing-cta">I can help grow your organization by solving difficult business problems with data, creativity and deep experience.</p>
                    <p class="landing-examples">Here are some examples of where I have done this before:</p>
                </div>
                
                <div class="case-study-cards">
                    <a href="#product-ownership" class="case-study-card" data-case="product-ownership">
                        <div class="case-study-card-title">
                            <span class="subheading-hex"></span>
                            Innovation at Scale
                        </div>
                        <div class="case-study-card-description">
                            Transformed data collection on Britain's largest infrastructure project — scaling innovation from 3 users to industry catalyst, deploying 120 iPads with zero data loss across 37,000 records.
                        </div>
                    </a>

                    <a href="#geospatial-recovery" class="case-study-card" data-case="geospatial-recovery">
                        <div class="case-study-card-title">
                            <span class="subheading-hex"></span>
                            Geospatial Leadership
                        </div>
                        <div class="case-study-card-description">
                            Defended a $300K payment dispute on a 100,000m³ earthworks program with multi-pipeline spatial validation — original invoice accepted without revision through rigorous cross-validation.
                        </div>
                    </a>

                    <a href="#digital-delivery" class="case-study-card" data-case="digital-delivery">
                        <div class="case-study-card-title">
                            <span class="subheading-hex"></span>
                            Digital Delivery
                        </div>
                        <div class="case-study-card-description">
                            Built and led a 14-person global technical team in 6 months, deployed enterprise platforms meeting strict data residency requirements, and unlocked $10M+ contract pipeline.
                        </div>
                    </a>
                </div>
            </div>
            
            <div>
                <canvas id="landingPortrait" class="landing-portrait"></canvas>
                
                <div class="landing-availability">
                    <div class="availability-text">
                        Currently exploring senior technology leadership opportunities, targeting environmental, AEC, infrastructure, energy, natural resources and software sectors.
                        <br><br>
                        Based in Vancouver Island, BC | Open to remote and hybrid roles | Available immediately
                    </div>
                    
                    <div class="availability-contact">
                        <a href="mailto:jurgenvanwessel@outlook.com" class="availability-icon-link" title="Email: jurgenvanwessel@outlook.com">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
                                <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
                                <polyline points="22,6 12,13 2,6"/>
                            </svg>
                        </a>
                        <a href="https://linkedin.com/in/jurgenvanwessel" target="_blank" rel="noopener" class="availability-icon-link" title="LinkedIn Profile">
                            <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                            </svg>
                        </a>
                        <a href="mailto:jurgenvanwessel@outlook.com?subject=Portfolio%20resume%20request" class="availability-resume-link" title="Request Resume">
                            Resume on request
                        </a>
                    </div>
                    
                    <div class="availability-roles">
                        <strong>Target roles:</strong> Director of Geospatial Technology • Senior Digital Delivery Manager • VP Product • Senior Technical Projects Manager • Director of Innovation • CTO • Director of Technical Operations
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PAGE LAYOUT -->
    <div class="page-wrapper" id="caseStudyWrapper">
        <div class="content">
            <div class="text-section">

                <!-- CASE STUDY 1: PRODUCT OWNERSHIP / HS2 -->
                <div class="case-study" id="product-ownership">
                    <div>
                        <h1>I transformed data collection on Britain's largest infrastructure project — scaling innovation from 3 users to industry catalyst</h1>
                        <div class="subheading">
                            <span class="subheading-hex"></span>
                            England // HS2 High Speed Rail Program
                        </div>
                    </div>
                    
                    <div class="description">
                        <p>Following successful delivery of <a href="https://archaeologydataservice.ac.uk/archives/collections/view/1003796/index.cfm" target="_blank" rel="noopener">Europe's largest archaeological project</a>, I identified a critical industry problem: traditional recording methods couldn't scale to meet the demands of <a href="https://www.theguardian.com/science/2018/oct/26/story-of-a-nation-hs2-rail-archaeological-dig-begins-in-uks-biggest-excavation" target="_blank" rel="noopener">High Speed 2's major cemetery excavation program</a> — 12,500+ burials, 160 archaeologists operating to an accelerated schedule. When working with human remains there is no margin for data loss. I led the development of an industry-proof field data collection platform, built the supporting teams, business models and reporting, driving successful project delivery and a lasting legacy.</p>
                        
                        <div class="stats">
                            <div class="stat-item">
                                <span class="stat-number">120 iPads</span>
                                <span class="stat-label">deployed across two major project sites</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number">$400K</span>
                                <span class="stat-label">in innovation funding secured</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number">zero</span>
                                <span class="stat-label">data loss across 37,000 records</span>
                            </div>
                        </div>
                        
                        <p><strong>Result:</strong> Largest commercial deployment of paperless recording in UK archaeology. $500K+ efficiency savings through 10% productivity gains and elimination of 2,500 person-days of post-excavation data entry. System became operational standard across company with 100+ active users managing hundreds of thousands of records annually. Contributed to major HS2 archiving contract win.</p>
                    </div>
                    
                    <div class="details">
                        <div class="details-toggle" onclick="toggleDetails('hs2')">Technical Details</div>
                        <div class="details-content" id="hs2DetailsContent">
                            <p><strong>Challenge:</strong> The £42M London cemetery excavation alone would generate £30K+ in archival storage costs and create massive post-excavation backlogs. The solution required not just new technology, but fundamental transformation of UK archaeological practice.</p>
                            
                            <p><strong>Strategic Vendor Selection:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Conducted comprehensive analysis of potential platforms</li>
                                <li>Selected California-based startup (<a href="https://codifi.com/" target="_blank" rel="noopener">Codifi</a>) over simpler options based on very clean data model built for archaeology, flexible synchronization and shared vision</li>
                                <li>Developed and agreed bespoke commercial model: negotiated enterprise licensing; separated hardware from software development; integrated support team into wider project budget</li>
                            </ul>
                            
                            <p><strong>Funding & Stakeholder Navigation:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Secured HS2 Innovation Panel funding through business case demonstrating performance improvements and data quality gains</li>
                                <li>Built case with partner organizations to develop robust external solution rather than build in-house with stretched capacity</li>
                                <li>Managed demanding Tier 1 client: delivered extensive briefing materials, financial models, and risk assessments</li>
                            </ul>
                            
                            <p><strong>Deployment & Scale Management (Operating Remotely):</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>I served as Innovation Manager and client-side product owner: managed agile development sprints, user story prioritization, cross-functional specialist consultation</li>
                                <li>Built complete technical infrastructure: procured/configured 120 iPads with industrial charging/syncing systems; established offline-first data architecture with robust backup protocols</li>
                                <li>Developed training methodology using digitization of legacy paper records as hands-on learning</li>
                                <li>Crisis management: When iPad delivery delays threatened deployment, orchestrated rotating half-day schedules to ensure continuity</li>
                            </ul>
                            
                            <p><strong>Legacy & Commercial Scale:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Negotiated formal business partnership and long-term roadmap</li>
                                <li>Built 10-person Technical Services team from ground up; trained successor who continues to lead development of the platform</li>
                                <li>Created replicable methodology extended beyond cemeteries to trial trenching and other archaeological and adjacent fieldwork</li>
                                <li>System remains operational standard with 100+ active users managing hundreds of thousands of records annually</li>
                            </ul>
                            
                            <p><strong>Quantified Impact:</strong> 22% archaeological productivity increase in controlled trials; 23% improvement in data completeness; 95% reduction in archival costs; contributed to major contract win where digital capabilities were critical differentiator.</p>
                        </div>
                    </div>
                    
                    <div class="image-placeholder">
                        <img src="hs2-field-recording.png" alt="Archaeologist using iPad for digital field recording on HS2 excavation" class="project-image">
                    </div>
                </div>

                <!-- CASE STUDY 2: GEOSPATIAL RECOVERY / AWPR -->
                <div class="case-study" id="geospatial-recovery">
                    <div>
                    <h1>I defended a $300K payment dispute on a 100,000m³ earthworks program with multi-pipeline spatial validation</h1>
                    <div class="subheading">
                        <span class="subheading-hex"></span>
                        Scotland // Aberdeen Western Peripheral Route
                    </div>
                </div>
                
                <div class="description">
                    <p>When the principal consultant challenged our topsoil volume calculations without independent measurements, I rebuilt confidence through rigorous cross-validation rather than defensive revisions.</p>
                    
                    <div class="stats">
                        <div class="stat-item">
                            <span class="stat-number">100,000m³</span>
                            <span class="stat-label">topsoil stripped</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">4 geo-pipelines</span>
                            <span class="stat-label">to validate volume calculations</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">zero</span>
                            <span class="stat-label">further earthworks QS issues</span>
                        </div>
                    </div>
                    
                    <p><strong>Result:</strong> Original invoice accepted without revision. Client confidence strengthened. Improved methodology became project standard for heritage on the $1.4B scheme.</p>
                </div>
                
                <div class="details">
                    <div class="details-toggle" onclick="toggleDetails()">Technical Details</div>
                <div class="details-content" id="detailsContent">
                    <p><strong>Context:</strong> 4 year involvement on Scotland's largest infrastructure project, managing survey and spatial data for the whole scheme and all operations for the northern half. Embedded surveyors using Trimble R6 GPS and Leica total stations set out and recorded thousands of machine trial trenches and excavation features.</p>
                    
                    <p><strong>Payment structure:</strong> Volume-based billing for topsoil stripping, calculated on compressed (in-ground) volumes. Regular GPS topographic surveys captured pre-strip and daily progress.</p>
                    
                    <p><strong>The challenge:</strong> One site's calculations had been genuinely over-estimated due to complex topography and insufficient survey point density. Rather than accept the loss, I used it as an opportunity to validate everything.</p>
                    
                    <p><strong>Validation geo-pipeline:</strong></p>
                    <ol style="margin-left: 20px; margin-bottom: 10px;">
                        <li>On-board GPS calculations (Trimble Access)</li>
                        <li>Trimble Business Center processing</li>
                        <li>Surfer grid-based surface models</li>
                        <li>KTF (client's software) cross-check</li>
                    </ol>
                    <ul style="margin-left: 40px; margin-bottom: 10px;">
                        <li>Sense-checked with Excel-driven boundary analysis for upper/lower bounds</li>
                        <li>Further validated with physical spoil heap surveys with expansion factors</li>
                    </ul>
                    
                    <p><strong>Findings:</strong> Averaged results across all pipelines, removed outliers where model quality was questionable. We had actually slightly under-charged the client on average across all sites.</p>
                    
                    <p><strong>Process improvements:</strong> Tightened QA procedures and documentation to incorporate redundancy in validation. Today's approach would use drone photogrammetry with automated processing and parallel validation pipelines.</p>
                </div>
            </div>
            
            <div class="image-placeholder">
                <img src="excavator.jpg" alt="Topsoil stripping on Aberdeen Western Peripheral Route" class="project-image">
            </div>
                </div>

                <!-- CASE STUDY 3: DIGITAL DELIVERY / CHRONICLE HERITAGE SAUDI ARABIA -->
                <div class="case-study" id="digital-delivery">
                    <div>
                        <h1>I delivered a world-class digital archaeology capability driving record growth in Saudi Arabia</h1>
                        <div class="subheading">
                            <span class="subheading-hex"></span>
                            Saudi Arabia // NEOM, AlUla, Diriyah, Soudah
                        </div>
                    </div>
                    
                    <div class="description">
                        <p>Our organization was positioned to capitalize on Saudi's massive infrastructure and heritage development boom but we needed a differentiator. My remit was to build a digital archaeology operation that would spotlight our technological prowess; could scale rapidly in both service lines and geographies, while meeting increasingly stringent government data residency requirements.</p>
                        
                        <div class="stats">
                            <div class="stat-item">
                                <span class="stat-number">14 strong</span>
                                <span class="stat-label">technical team hired in 6 months</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number">85%+</span>
                                <span class="stat-label">average team utilization</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-number">$10M+</span>
                                <span class="stat-label">contract pipeline unlocked</span>
                            </div>
                        </div>
                        
                        <p><strong>Result:</strong> Built and led a remarkable, global team of specialists providing GIS, survey, IT, data management and 3D digital documentation support to a wide range of projects and clients. Developed world-class 3D documentation pipeline and led major heritage recording projects from proposal to archive. Deployed enterprise platforms (Egnyte, ArcGIS Enterprise) in-country, positioning our organization to win substantial government contracts with strong data residency requirements.</p>
                    </div>
                    
                    <div class="details">
                        <div class="details-toggle" onclick="toggleDetails('chronicle')">Technical Details</div>
                        <div class="details-content" id="chronicleDetailsContent">
                            <p><strong>Challenge:</strong> Saudi Arabia's heritage boom demanded rapid scaling without losing quality. Competitors were building similar capabilities, and data residency requirements were becoming deal-breakers on major contracts. The clock was ticking.</p>
                            
                            <p><strong>Built a Structured, Billable Technology Team:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Recruited and organized 14 specialists across IT, data management, GIS, metric survey, photogrammetry, laser scanning, archaeological practice, and 3D visualization</li>
                                <li>Created career pathways and clear accountability while maintaining 85%+ billable utilization</li>
                                <li>Built revenue-generating capability that paid for its own innovation time</li>
                                <li>Became technical backbone for high-profile projects across Saudi Arabia, Oman, UAE, US, and Europe</li>
                            </ul>
                            
                            <p><strong>Standardized Delivery During Hypergrowth:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Introduced Project Standards documents — succinct, project-specific guides defining tools, numbering sequences, data structures, photo documentation requirements</li>
                                <li>Upgraded survey methodology to modern standards: procured professional-grade total stations and GNSS equipment</li>
                                <li>Organized training programs and built data transformation pipelines</li>
                                <li>Set spatial accuracy requirements for different feature types based on UK infrastructure experience</li>
                                <li>Created repeatable QA/QC frameworks that worked across archaeological, heritage, and civil contexts</li>
                            </ul>
                            
                            <p><strong>Delivered World-Class 3D Documentation:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Cloud-based processing infrastructure: fully automated Azure-based photogrammetry processing</li>
                                <li>Fallback to two custom-built in-country "supercomputers" for data residency compliance</li>
                                <li>Automated QA checks and mesh optimization workflows</li>
                                <li>Enterprise license with Nira.app (white-labeled web-based 3D viewer)</li>
                                <li>Custom modifications and deep integration into project QA workflows</li>
                                <li>Client-facing handover processes with automated metadata injection</li>
                            </ul>
                            
                            <p><strong>Solved Data Residency for $10M+ Contract Pipeline:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li><strong>Egnyte Cloud Storage (Saudi Instance):</strong> Deployed second cloud storage instance with Saudi data residency; maintained global connectivity while meeting government compliance requirements</li>
                                <li><strong>ArcGIS Enterprise (Google Cloud Platform, Saudi Arabia):</strong> Full project management from scoping through rollout; navigated unresponsive ESRI technical teams; deployed enterprise GIS platform to in-country GCP servers; connected mobile data collection tools (ArcGIS FieldMaps, Survey123); designed training programs and data models; implemented IAM connected to core US systems</li>
                                <li>This wasn't just IT infrastructure — it was a strategic capability that unlocked tens of millions of dollars in government contracts that competitors couldn't bid on</li>
                            </ul>
                            
                            <p><strong>Advanced the Regional Heritage Platform Vision:</strong></p>
                            <ul style="margin-left: 20px; margin-bottom: 10px;">
                                <li>Laid groundwork for white-label regional heritage database platform by repurposing Chronicle's in-house Codifi system</li>
                                <li>Multiple rounds of stakeholder promotion and proof-of-concept demonstrations</li>
                                <li>Technology mapping sessions with development team</li>
                                <li>Market positioning and requirements definition for eventual commercialization</li>
                            </ul>
                            
                            <p><strong>Quantified Impact:</strong> 700% team growth in 6 months while maintaining 85%+ billable utilization. $10M+ contract pipeline unlocked through data residency compliance. Zero security incidents across enterprise platform deployment meeting strict government requirements.</p>
                        </div>
                    </div>
                    
                    <div class="image-placeholder">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; max-width: 700px; margin: 0 auto; padding: 20px;">
                            <div style="display: flex; align-items: center; justify-content: center; min-height: 140px;">
                                <img src="alula-logo.png" alt="Royal Commission for AlUla" style="max-width: 100%; max-height: 140px; width: auto; height: auto; object-fit: contain;">
                            </div>
                            <div style="display: flex; align-items: center; justify-content: center; min-height: 140px;">
                                <img src="neom-logo.png" alt="NEOM" style="max-width: 100%; max-height: 140px; width: auto; height: auto; object-fit: contain;">
                            </div>
                            <div style="display: flex; align-items: center; justify-content: center; min-height: 140px;">
                                <img src="diriyah-logo.png" alt="Diriyah Gate Development Authority" style="max-width: 100%; max-height: 140px; width: auto; height: auto; object-fit: contain;">
                            </div>
                            <div style="display: flex; align-items: center; justify-content: center; min-height: 140px;">
                                <img src="soudah-logo.webp" alt="Soudah Development Company" style="max-width: 100%; max-height: 140px; width: auto; height: auto; object-fit: contain;">
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        
        <div class="hero">
            <div class="map-container" id="mapContainer">
                <div id="map"></div>
                <canvas id="canvas"></canvas>
                <div class="debug-info" id="debugInfo"></div>
                <div class="keymap-tooltip" id="keymapTooltip">
                    <div class="keymap-mobile-message">
                        ðŸ¥š You found the easter egg!<br>
                        This egg currently only works on desktop.<br>
                        It's on the list!
                    </div>
                    <div class="keymap-section">
                        <div class="keymap-title">MAP NAVIGATION</div>
                        <div class="keymap-item">
                            <div><span class="keymap-key">W</span><span class="keymap-key">A</span><span class="keymap-key">S</span><span class="keymap-key">D</span></div>
                            <div class="keymap-action">Pan</div>
                        </div>
                        <div class="keymap-item">
                            <div><span class="keymap-key">+</span><span class="keymap-key">-</span></div>
                            <div class="keymap-action">Zoom</div>
                        </div>
                    </div>
                    <div class="keymap-section">
                        <div class="keymap-title">DEBUG LAYERS</div>
                        <div class="keymap-item">
                            <span class="keymap-key" data-key="1">1</span>
                            <div class="keymap-action">Base map</div>
                        </div>
                        <div class="keymap-item">
                            <span class="keymap-key" data-key="2">2</span>
                            <div class="keymap-action">Boundaries</div>
                        </div>
                        <div class="keymap-item">
                            <span class="keymap-key" data-key="3">3</span>
                            <div class="keymap-action">Point grid</div>
                        </div>
                        <div class="keymap-item">
                            <span class="keymap-key" data-key="4">4</span>
                            <div class="keymap-action">Hexagons</div>
                        </div>
                        <div class="keymap-item">
                            <span class="keymap-key" data-key="5">5</span>
                            <div class="keymap-action">Animation</div>
                        </div>
                    </div>
                    <div class="keymap-section">
                        <div class="keymap-title">INFO</div>
                        <div class="keymap-item">
                            <span class="keymap-key">i</span>
                            <div class="keymap-action">GIS writeup</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- GIS MODAL -->
    <div class="gis-modal-overlay" id="gisModal">
        <div class="gis-modal">
            <button class="gis-modal-close" onclick="closeGISModal()">×</button>
            <h2>How This Map Works</h2>
            
            <p>This hexagonal visualization is a fully functional geospatial system, built entirely as a single HTML file. No backend, no database, no tile server for the boundaries â€” just client-side GIS running in the browser.</p>
            
            <h3>Coordinate Systems & Projection</h3>
            <p>The underlying map tiles render in <code>EPSG:3857</code> (Web Mercator), which is the standard for web mapping. Country boundary polygons are stored as <code>EPSG:4326</code> (WGS84 lon/lat) GeoJSON. On every render pass, each boundary vertex is projected from geographic coordinates into pixel space using Leaflet's <code>latLngToContainerPoint()</code> â€” a fast Web Mercator forward projection. The hexagon grid is then tessellated entirely in screen space, with each centre point tested against the projected polygons.</p>
            
            <h3>Two-Phase Boundary Loading</h3>
            <p>To keep the page feeling instant while still supporting worldwide panning, the boundaries load in two phases. A simplified UK/Ireland polygon (~500 vertices, derived from Natural Earth 110m data) is embedded directly in the HTML. This lets the Scotland hexagon animation run within a couple hundred milliseconds of page load â€” no network request required.</p>
            <p>In the background, the full worldwide Natural Earth dataset fetches asynchronously. Once it arrives, a spatial index is built and the system silently upgrades. The silver navigation hexagon only appears at this point, as a subtle signal that worldwide mode is ready.</p>
            
            <h3>Spatial Indexing</h3>
            <p>The worldwide dataset contains ~195 country polygons. Without optimisation, every pan or zoom would require projecting all of them into screen coordinates â€” most of which aren't visible. To solve this, each country's bounding box is indexed in a simple R-tree structure on load. Before any coordinate conversion, a viewport query returns only the countries whose bounding boxes intersect the current map extent. Typically that's 1â€“5 polygons instead of 195.</p>
            
            <h3>Hexagonal Tessellation & Point-in-Polygon</h3>
            <p>The hex grid uses flat-top orientation with standard offset coordinates: <code>hexWidth = √3 × size</code>, <code>rowHeight = 1.5 × size</code>, with odd rows shifted by <code>hexWidth / 2</code>. Each hex centre is tested against the screen-space boundary polygons using a ray-casting algorithm â€” casting a horizontal ray and counting edge crossings to determine inside/outside. Aberdeen (57.15°N, 2.09°W) is flagged within a 0.3° radius and rendered in red.</p>
            
            <h3>Animation</h3>
            <p>Each hexagon animates via a <code>scaleY = cos(θ)</code> transform, creating the appearance of flipping in from edge-on. The animation staggers by row (50ms per row) with cubic ease-out and a small sine-wave bounce at the end. The entire animation re-runs whenever hexagons are regenerated â€” on pan, zoom, or resize.</p>
            
            <h3>Resize Handling</h3>
            <p>Window resize is the trickiest part. The map container height is bound to the text column height, so resizing can change both simultaneously. All canvas drawing is suspended during resize (an <code>isResizing</code> flag gates every draw call), the canvas is hidden, and recalculation only fires after a 300ms debounce once the layout has settled. This prevents the stutter you'd otherwise see from repeated expensive polygon operations mid-resize.</p>
            
            <h3>Why a Single File?</h3>
            <p>This is a portfolio piece, not a production application. The constraint of a single HTML file is actually a feature â€” it's portable, requires no build step, and can be opened from anywhere. The GIS techniques used here (spatial indexing, viewport culling, progressive loading) are the same ones you'd reach for in a production system, just implemented in a context where they have to pull their weight without any infrastructure behind them.</p>
            
            <p style="margin-top: 30px; font-size: 0.85rem; color: #8B7355; font-style: italic;">Press Escape or click outside to close.</p>
        </div>
    </div>

    <!-- LEAFLET -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
    // ============================================================
    // STATE
    // ============================================================
    let map, canvas, ctx;
    let debugMode = 0;
    let hexagons = [];
    let animationStartTime = null;
    let isResizing = false;
    let worldwideLoaded = false;
    let navHexRevealed = false;     // one-shot: nav hex pop-in has fired
    let spatialIndex = null;       // Built once worldwide data arrives
    let geoJsonData = null;        // Current active boundary dataset

    // ============================================================
    // EMBEDDED UK/IRELAND BOUNDARIES (Natural Earth 110m, ~500 verts)
    // Used for instant first render. Replaced once worldwide loads.
    // ============================================================
    const EMBEDDED_BOUNDARIES = {"type":"FeatureCollection","features":[{"type":"Feature","properties":{"ADMIN":"United Kingdom"},"geometry":{"type":"MultiPolygon","coordinates":[[[[-5.662,54.555],[-6.198,53.868],[-6.954,54.074],[-7.572,54.06],[-7.366,54.596],[-7.572,55.132],[-6.734,55.173],[-5.662,54.555]]],[[[-3.005,58.635],[-4.074,57.553],[-3.055,57.69],[-1.959,57.685],[-2.22,56.87],[-3.119,55.974],[-2.085,55.91],[-2.006,55.805],[-1.115,54.625],[-0.43,54.464],[0.185,53.325],[0.47,52.93],[1.682,52.74],[1.56,52.1],[1.051,51.807],[1.45,51.289],[0.55,50.766],[-0.788,50.775],[-2.49,50.5],[-2.956,50.697],[-3.617,50.228],[-4.543,50.342],[-5.245,49.96],[-5.777,50.16],[-4.31,51.21],[-3.415,51.426],[-3.423,51.427],[-4.984,51.593],[-5.267,51.991],[-4.222,52.301],[-4.77,52.84],[-4.58,53.495],[-3.094,53.404],[-3.092,53.404],[-2.945,53.985],[-3.615,54.601],[-3.63,54.615],[-4.844,54.791],[-5.083,55.062],[-4.719,55.508],[-5.048,55.784],[-5.586,55.311],[-5.645,56.275],[-6.15,56.785],[-5.787,57.819],[-5.01,58.63],[-4.211,58.551],[-3.005,58.635]]]]}},{"type":"Feature","properties":{"ADMIN":"Ireland"},"geometry":{"type":"Polygon","coordinates":[[[-6.198,53.868],[-6.033,53.153],[-6.789,52.26],[-8.562,51.669],[-9.977,51.82],[-9.166,52.865],[-9.689,53.881],[-8.328,54.665],[-7.572,55.132],[-7.366,54.596],[-7.572,54.06],[-6.954,54.074],[-6.198,53.868]]]}}]};

    // ============================================================
    // SPATIAL INDEX (simple bounding-box R-tree)
    // ============================================================
    class SpatialIndex {
        constructor() { this.items = []; }

        insert(minLng, minLat, maxLng, maxLat, index) {
            this.items.push({ minLng, minLat, maxLng, maxLat, index });
        }

        query(west, south, east, north) {
            const results = [];
            for (const item of this.items) {
                if (item.maxLng >= west && item.minLng <= east &&
                    item.maxLat >= south && item.minLat <= north) {
                    results.push(item.index);
                }
            }
            return results;
        }
    }

    function buildSpatialIndex(features) {
        const idx = new SpatialIndex();
        features.forEach((feature, i) => {
            if (!feature.geometry) return;
            let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

            const scan = (coords) => {
                for (const [lng, lat] of coords) {
                    if (lng < minLng) minLng = lng;
                    if (lng > maxLng) maxLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                }
            };

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates.forEach(scan);
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(poly => poly.forEach(scan));
            }

            idx.insert(minLng, minLat, maxLng, maxLat, i);
        });
        return idx;
    }

    // ============================================================
    // GEOMETRY: project boundaries to screen polygons
    // Uses spatial index if available to filter first
    // ============================================================
    function getScreenPolygons() {
        if (!geoJsonData || !map) return [];

        // Determine which features to process
        let features;
        if (spatialIndex) {
            const b = map.getBounds();
            const indices = spatialIndex.query(b.getWest(), b.getSouth(), b.getEast(), b.getNorth());
            features = indices.map(i => geoJsonData.features[i]);
        } else {
            features = geoJsonData.features;
        }

        const polygons = [];

        features.forEach(feature => {
            if (!feature.geometry) return;

            const projectRing = (ring) => {
                const screen = [];
                for (const [lng, lat] of ring) {
                    const pt = map.latLngToContainerPoint([lat, lng]);
                    if (pt && !isNaN(pt.x) && !isNaN(pt.y)) {
                        screen.push([pt.x, pt.y]);
                    }
                }
                return screen.length >= 3 ? screen : null;
            };

            if (feature.geometry.type === 'Polygon') {
                feature.geometry.coordinates.forEach(ring => {
                    const p = projectRing(ring);
                    if (p) polygons.push(p);
                });
            } else if (feature.geometry.type === 'MultiPolygon') {
                feature.geometry.coordinates.forEach(poly =>
                    poly.forEach(ring => {
                        const p = projectRing(ring);
                        if (p) polygons.push(p);
                    })
                );
            }
        });

        return polygons;
    }

    // ============================================================
    // POINT-IN-POLYGON (ray casting)
    // ============================================================
    function pointInPolygon(px, py, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i][0], yi = polygon[i][1];
            const xj = polygon[j][0], yj = polygon[j][1];
            if (((yi > py) !== (yj > py)) &&
                (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    function isOverLand(x, y, screenPolygons) {
        for (const poly of screenPolygons) {
            if (pointInPolygon(x, y, poly)) return true;
        }
        return false;
    }

    // ============================================================
    // HEXAGON CLASS
    // ============================================================
    class Hexagon {
        constructor(x, y, size, row, latLng, isNavHex) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.row = row;
            this.latLng = latLng;
            this.isNavHex = isNavHex || false;
            this.rotation = 90;
            this.opacity = 0;
            this.animationDelay = row * 50;
            this.startTime = null;

            // Location-based highlighting
            this.isHighlighted = false;
            if (latLng && !this.isNavHex) {
                if (currentCaseStudy === 'geospatial-recovery') {
                    // Aberdeen detection (for AWPR case study)
                    const d = Math.sqrt(Math.pow(latLng.lat - 57.15, 2) + Math.pow(latLng.lng + 2.09, 2));
                    this.isHighlighted = d < 0.3;
                } else if (currentCaseStudy === 'product-ownership') {
                    // HS2 route detection (London to Birmingham)
                    const london = {lat: 51.5, lng: -0.1};
                    const birmingham = {lat: 52.5, lng: -1.9};
                    const distToLine = this.pointToLineDistance(latLng, london, birmingham);
                    this.isHighlighted = distToLine < 0.15;
                } else if (currentCaseStudy === 'digital-delivery') {
                    // Saudi Arabia project locations
                    const locations = [
                        {lat: 28.0, lng: 35.5, radius: 0.8},   // NEOM
                        {lat: 24.75, lng: 46.57, radius: 0.5}, // Riyadh/Diriyah
                        {lat: 26.6, lng: 37.9, radius: 0.8},   // AlUla (increased radius)
                        {lat: 18.27, lng: 42.37, radius: 0.6}  // Soudah
                    ];
                    for (const loc of locations) {
                        const d = Math.sqrt(Math.pow(latLng.lat - loc.lat, 2) + Math.pow(latLng.lng - loc.lng, 2));
                        if (d < loc.radius) {
                            this.isHighlighted = true;
                            break;
                        }
                    }
                }
            }
        }

        pointToLineDistance(point, lineStart, lineEnd) {
            const A = point.lat - lineStart.lat;
            const B = point.lng - lineStart.lng;
            const C = lineEnd.lat - lineStart.lat;
            const D = lineEnd.lng - lineStart.lng;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = lineStart.lat;
                yy = lineStart.lng;
            } else if (param > 1) {
                xx = lineEnd.lat;
                yy = lineEnd.lng;
            } else {
                xx = lineStart.lat + param * C;
                yy = lineStart.lng + param * D;
            }
            
            const dx = point.lat - xx;
            const dy = point.lng - yy;
            
            return Math.sqrt(dx * dx + dy * dy);
        }

        getPoints() {
            const pts = [];
            for (let i = 0; i < 6; i++) {
                const a = Math.PI / 3 * i - Math.PI / 6;
                pts.push([this.x + this.size * Math.cos(a), this.y + this.size * Math.sin(a)]);
            }
            return pts;
        }

        startAnimation(now) {
            if (!this.startTime) this.startTime = now + this.animationDelay;
        }

        update(now) {
            if (!this.startTime || now < this.startTime) return false;
            const elapsed = now - this.startTime;
            const duration = 392; // 30% faster (was 560)
            const progress = Math.min(elapsed / duration, 1);
            const easeOut = 1 - Math.pow(1 - progress, 3);

            this.rotation = 90 - (90 * easeOut);
            if (progress > 0.6) {
                const bp = (progress - 0.6) / 0.4;
                this.rotation -= Math.sin(bp * Math.PI) * 8;
            }
            this.opacity = easeOut;
            return progress >= 1;
        }

        draw(ctx) {
            ctx.save();

            // Nav hex: one-shot pop-in after land hexes complete
            if (this.isNavHex) {
                // Don't draw until we explicitly start the pop-in animation
                if (!this.navPopStart) {
                    ctx.restore();
                    return;
                }

                // After the first pop-in completes, just draw at full size forever
                if (navHexRevealed) {
                    ctx.globalAlpha = 1;
                    const pts = this.getPoints();
                    const buf = 1.5;
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(this.x + (pts[0][0] - this.x) * (1 - buf / this.size), this.y + (pts[0][1] - this.y) * (1 - buf / this.size));
                    for (let i = 1; i < pts.length; i++) {
                        ctx.lineTo(this.x + (pts[i][0] - this.x) * (1 - buf / this.size), this.y + (pts[i][1] - this.y) * (1 - buf / this.size));
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    return;
                }

                // One-shot pop-in animation (navPopStart is set by animation loop)
                const elapsed = performance.now() - this.navPopStart;
                const dur = 500;
                const t = Math.min(elapsed / dur, 1);
                // Elastic overshoot easing
                const eased = t === 1 ? 1 : 1 - Math.pow(2, -10 * t) * Math.cos((t * 10 - 0.75) * (2 * Math.PI) / 3);
                const scale = 0.4 + 0.6 * eased;   // 0.4 â†’ 1
                const alpha = Math.min(eased * 1.2, 1); // slightly faster fade

                if (t >= 1) navHexRevealed = true;  // pop-in done, lock it

                ctx.translate(this.x, this.y);
                ctx.scale(scale, scale);
                ctx.translate(-this.x, -this.y);
                ctx.globalAlpha = alpha;

                const pts = this.getPoints();
                const buf = 1.5;
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(this.x + (pts[0][0] - this.x) * (1 - buf / this.size), this.y + (pts[0][1] - this.y) * (1 - buf / this.size));
                for (let i = 1; i < pts.length; i++) {
                    ctx.lineTo(this.x + (pts[i][0] - this.x) * (1 - buf / this.size), this.y + (pts[i][1] - this.y) * (1 - buf / this.size));
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                return;
            }

            // --- Regular land hexagons: existing flip animation ---
            const scaleY = Math.cos(this.rotation * Math.PI / 180);
            ctx.translate(this.x, this.y);
            ctx.scale(1, scaleY);
            ctx.translate(-this.x, -this.y);
            ctx.globalAlpha = this.opacity;

            const pts = this.getPoints();
            const buf = 1.5;
            ctx.fillStyle = this.isHighlighted ? '#B8342E' : '#6B5442';

            ctx.beginPath();
            ctx.moveTo(
                this.x + (pts[0][0] - this.x) * (1 - buf / this.size),
                this.y + (pts[0][1] - this.y) * (1 - buf / this.size)
            );
            for (let i = 1; i < pts.length; i++) {
                ctx.lineTo(
                    this.x + (pts[i][0] - this.x) * (1 - buf / this.size),
                    this.y + (pts[i][1] - this.y) * (1 - buf / this.size)
                );
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        containsPoint(px, py) {
            return pointInPolygon(px, py, this.getPoints());
        }
    }

    // ============================================================
    // HEXAGON GENERATION
    // ============================================================
    function generateHexagons() {
        const screenPolys = getScreenPolygons();
        hexagons = [];
        window.navHex = null;

        const hexSize = 12;
        const hexWidth = Math.sqrt(3) * hexSize;
        const rowHeight = hexSize * 1.5;

        let rowIndex = 0;
        let maxRow = 0;
        let maxXForBottomRow = 0;

        for (let y = hexSize; y <= canvas.height - hexSize; y += rowHeight) {
            const xOffset = (rowIndex % 2) * (hexWidth / 2);
            let hasHex = false;

            for (let x = hexSize + xOffset; x <= canvas.width - hexSize; x += hexWidth) {
                if (isOverLand(x, y, screenPolys)) {
                    const latLng = map.containerPointToLatLng([x, y]);
                    hexagons.push(new Hexagon(x, y, hexSize, rowIndex, latLng, false));
                    hasHex = true;

                    if (y > canvas.height - hexSize * 2) {
                        maxXForBottomRow = Math.max(maxXForBottomRow, x);
                    }
                }
            }

            if (hasHex) maxRow = rowIndex;
            rowIndex++;
        }

        // Nav hex: snap to grid on bottom row, rightmost position
        const navY = hexSize + (maxRow * rowHeight);
        const navXOffset = (maxRow % 2) * (hexWidth / 2);
        let navX = hexSize + navXOffset;
        for (let x = hexSize + navXOffset; x <= canvas.width - hexSize; x += hexWidth) {
            if (x >= maxXForBottomRow - hexWidth && x + hexSize <= canvas.width) {
                navX = x;
            }
        }

        if (navX + hexSize <= canvas.width && navY + hexSize <= canvas.height) {
            const nav = new Hexagon(navX, navY, hexSize, maxRow, null, true);
            hexagons.push(nav);
            window.navHex = nav;
        }
    }

    // ============================================================
    // ANIMATION LOOP
    // ============================================================
    function animate(now) {
        if (isResizing) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let allDone = true;
        let landHexesDone = true;
        let maxLandHexEndTime = 0;
        
        for (const hex of hexagons) {
            if (!hex.isNavHex) {
                hex.startAnimation(now);
                
                // Track when this hex will finish (if it has started)
                if (hex.startTime) {
                    const hexEndTime = hex.startTime + 392; // duration
                    maxLandHexEndTime = Math.max(maxLandHexEndTime, hexEndTime);
                }
                
                const hexDone = hex.update(now);
                if (!hexDone) {
                    landHexesDone = false;
                    allDone = false;
                }
            }
            hex.draw(ctx);
        }
        
        // Debug logging every 100ms
        if (!window._lastDebugLog || now - window._lastDebugLog > 100) {
            console.log('Frame:', Math.round(now), 'landHexesDone:', landHexesDone, 'maxEndTime:', Math.round(maxLandHexEndTime), 'now < maxEnd+100:', now < maxLandHexEndTime + 100);
            window._lastDebugLog = now;
        }
        
        // Only consider land hexes done if ALL hexes are done AND we're past the last hex's end time
        if (landHexesDone && maxLandHexEndTime > 0 && now < maxLandHexEndTime + 100) {
            landHexesDone = false;
            allDone = false;
        }
        
        // Start nav hex pop-in AFTER land hexagons finish + visual settling time
        if (window.navHex && landHexesDone && !window.navHex.delayStart) {
            window.navHex.delayStart = now;
            console.log('🎯 TRIGGERING NAV HEX at', now, '- last hex ended at', maxLandHexEndTime);
        }
        
        if (window.navHex && window.navHex.delayStart && !window.navHex.navPopStart) {
            const delayElapsed = now - window.navHex.delayStart;
            // Wait 300ms pause after animation completes
            if (delayElapsed >= 300) {
                window.navHex.navPopStart = now;
                console.log('🎯 NAV HEX POP-IN STARTING at', now);
            } else {
                allDone = false; // Keep looping during delay
            }
        }

        // Keep looping if nav hex pop-in is still animating
        if (window.navHex && window.navHex.navPopStart) {
            const navElapsed = now - window.navHex.navPopStart;
            if (navElapsed < 500) allDone = false;
            
            // Trigger sparkle after nav hex completes (only once)
            if (navElapsed >= 500 && !window.navHex.sparkleStarted) {
                window.navHex.sparkleStarted = true;
                window.navHex.sparkleStart = now;
                console.log('Sparkle triggered at', now);
            }
        }
        
        // Draw sparkle AFTER all hexagons (so it appears on top)
        if (window.navHex && window.navHex.sparkleStart && now - window.navHex.sparkleStart < 800) {
            allDone = false;
            drawSparkle(now, window.navHex.sparkleStart);
        }

        if (!allDone) {
            requestAnimationFrame(animate);
        }
    }

    function triggerAnimation() {
        animationStartTime = null;
        hexagons.forEach(h => { 
            h.startTime = null; 
            h.rotation = 90; 
            h.opacity = 0; 
            if (h.isNavHex) {
                h.delayStart = null;
                h.navPopStart = null;
                h.sparkleStarted = false;
                h.sparkleStart = null;
            }
        });
        requestAnimationFrame(animate);
    }
    
    function drawSparkle(now, sparkleStart) {
        if (!window.navHex) return;
        
        const elapsed = now - sparkleStart;
        const duration = 800;
        const t = elapsed / duration;
        
        // Two pulses: 0-0.35 and 0.45-0.8
        let alpha = 0;
        let rayLength = 0;
        
        if (t < 0.35) {
            // First pulse - shoot out and fade
            const pulse = t / 0.35;
            alpha = Math.sin(pulse * Math.PI) * 0.8; // Brighter
            rayLength = pulse * 25; // Shoot out to 25px
        } else if (t >= 0.45 && t < 0.8) {
            // Second pulse - shoot out and fade
            const pulse = (t - 0.45) / 0.35;
            alpha = Math.sin(pulse * Math.PI) * 0.8;
            rayLength = pulse * 25;
        }
        
        if (alpha > 0 && rayLength > 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = '#FFFFFF'; // Bright white
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            
            // Draw 6 rays emanating from nav hex center at hex vertices
            const rayCount = 6;
            const hexRadius = window.navHex.size;
            
            for (let i = 0; i < rayCount; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6; // Align with hex points
                const startX = window.navHex.x + Math.cos(angle) * hexRadius;
                const startY = window.navHex.y + Math.sin(angle) * hexRadius;
                const endX = window.navHex.x + Math.cos(angle) * (hexRadius + rayLength);
                const endY = window.navHex.y + Math.sin(angle) * (hexRadius + rayLength);
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }

    // ============================================================
    // DEBUG MODES
    // ============================================================
    function setDebugMode(mode) {
        debugMode = mode;
        const info = document.getElementById('debugInfo');
        const mapEl = document.getElementById('map');

        if (mode === 0) {
            info.classList.remove('visible');
            mapEl.classList.remove('debug-visible');
            generateHexagons();
            triggerAnimation();
        } else {
            info.classList.add('visible');
            mapEl.classList.add('debug-visible');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (mode === 1) {
                info.textContent = 'Debug: Base Map';
            } else if (mode === 2) {
                info.textContent = 'Debug: Boundaries';
                drawBoundaries();
            } else if (mode === 3) {
                info.textContent = 'Debug: Point Grid';
                drawPointGrid();
            } else if (mode === 4) {
                info.textContent = 'Debug: Static Hexagons';
                drawHexagonsStatic();
            }
        }
    }

    function drawBoundaries() {
        const polys = getScreenPolygons();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        polys.forEach(poly => {
            ctx.strokeStyle = '#B8342E';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(poly[0][0], poly[0][1]);
            for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i][0], poly[i][1]);
            ctx.closePath();
            ctx.stroke();

            ctx.fillStyle = '#6B5442';
            poly.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        });
    }

    function drawPointGrid() {
        const polys = getScreenPolygons();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < canvas.height; y += 20) {
            for (let x = 0; x < canvas.width; x += 20) {
                const land = isOverLand(x, y, polys);
                ctx.fillStyle = land ? '#6B5442' : 'rgba(139,111,71,0.2)';
                ctx.beginPath();
                ctx.arc(x, y, land ? 2 : 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawHexagonsStatic() {
        const polys = getScreenPolygons();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const hexSize = 12, hexWidth = Math.sqrt(3) * hexSize, rowHeight = hexSize * 1.5, buf = 1.5;
        let row = 0;
        for (let y = hexSize; y <= canvas.height - hexSize; y += rowHeight) {
            const xOff = (row % 2) * (hexWidth / 2);
            for (let x = hexSize + xOff; x <= canvas.width - hexSize; x += hexWidth) {
                if (isOverLand(x, y, polys)) {
                    const pts = [];
                    for (let i = 0; i < 6; i++) {
                        const a = Math.PI / 3 * i - Math.PI / 6;
                        pts.push([x + hexSize * Math.cos(a), y + hexSize * Math.sin(a)]);
                    }
                    ctx.fillStyle = '#6B5442';
                    ctx.beginPath();
                    ctx.moveTo(x + (pts[0][0] - x) * (1 - buf / hexSize), y + (pts[0][1] - y) * (1 - buf / hexSize));
                    for (let i = 1; i < pts.length; i++) {
                        ctx.lineTo(x + (pts[i][0] - x) * (1 - buf / hexSize), y + (pts[i][1] - y) * (1 - buf / hexSize));
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }
            row++;
        }
    }

    // ============================================================
    // BACKGROUND WORLDWIDE LOAD
    // ============================================================
    async function loadWorldwideData() {
        const urls = [
            'https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson',
            'https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson'
        ];

        for (const url of urls) {
            try {
                const res = await fetch(url);
                if (res.ok) {
                    const data = await res.json();
                    console.log('Worldwide data loaded from:', url);

                    // Build spatial index
                    spatialIndex = buildSpatialIndex(data.features);
                    console.log('Spatial index built:', data.features.length, 'features');

                    // Swap in worldwide data
                    geoJsonData = data;
                    worldwideLoaded = true;

                    return; // Data loaded successfully
                }
            } catch (e) {
                console.log('Failed:', url, e.message);
            }
        }
        console.log('Worldwide load failed, staying with embedded boundaries');
        // No action needed - geoJsonData already has EMBEDDED_BOUNDARIES
    }

    // ============================================================
    // MODAL
    // ============================================================
    function closeGISModal() {
        document.getElementById('gisModal').classList.remove('visible');
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeGISModal();
    });

    document.getElementById('gisModal').addEventListener('click', (e) => {
        if (e.target.id === 'gisModal') closeGISModal();
    });

    // ============================================================
    // CASE STUDY NAVIGATION
    // ============================================================
    const caseStudyConfig = {
        'product-ownership': {
            center: [52.5, -1.5],  // Between London and Birmingham
            zoom: 6,  // Zoomed out one level from 7
            highlightType: 'hs2'
        },
        'geospatial-recovery': {
            center: [57.5, -4.0],  // Scotland
            zoom: 7,
            highlightType: 'aberdeen'
        },
        'digital-delivery': {
            center: [24.0, 42.0],  // Central Saudi Arabia
            zoom: 5,  // Show whole country
            highlightType: 'saudi-projects'
        }
    };

    let currentCaseStudy = null;

    function switchCaseStudy(caseId) {
        if (currentCaseStudy === caseId) return;
        
        const wasOnLanding = (currentCaseStudy === null);
        currentCaseStudy = caseId;
        
        // Scroll to top immediately
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
        // Hide landing page, show case study wrapper
        document.getElementById('landing-page').classList.remove('active');
        document.getElementById('caseStudyWrapper').style.display = 'grid';
        document.getElementById('navWrapper').classList.remove('hidden');
        
        // If coming from landing page, need to initialize map first
        if (wasOnLanding && !map) {
            initMap();
        }
        
        // Hide canvas immediately so old map disappears
        if (canvas) {
            canvas.style.opacity = '0';
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear immediately to prevent ghost
        }
        
        // Update case study visibility IMMEDIATELY - don't wait for map
        document.querySelectorAll('.case-study').forEach(cs => cs.classList.remove('active'));
        document.getElementById(caseId).classList.add('active');
        
        // Update nav links
        document.querySelectorAll('.nav-link[data-case]').forEach(link => {
            link.classList.toggle('active', link.dataset.case === caseId);
        });
        
        // Update URL hash without triggering hashchange
        history.replaceState(null, null, `#${caseId}`);
        
        // Use double RAF: first ensures content renders, second handles map
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                // Now update map (content is already visible)
                if (map && caseStudyConfig[caseId]) {
                    const config = caseStudyConfig[caseId];
                    
                    // Update map view
                    map.setView(config.center, config.zoom);
                    
                    // Update map height from headline to end of result section
                    const activeCase = document.querySelector('.case-study.active');
                    const mapContainer = document.getElementById('mapContainer');
                    if (activeCase && mapContainer) {
                        const h1 = activeCase.querySelector('h1');
                        const description = activeCase.querySelector('.description');
                        if (h1 && description) {
                            const h1Top = h1.getBoundingClientRect().top;
                            const descBottom = description.getBoundingClientRect().bottom;
                            const height = descBottom - h1Top;
                            mapContainer.style.height = height + 'px';
                            canvas.width = mapContainer.clientWidth;
                            canvas.height = mapContainer.clientHeight;
                            map.invalidateSize();
                        }
                    }
                    
                    // Clear canvas, regenerate hexagons, show canvas just before animation starts
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    generateHexagons();
                    canvas.style.opacity = '1';
                    triggerAnimation();
                }
            });
        });
    }

    function showLanding() {
        currentCaseStudy = null;
        
        // Show landing page, hide case study wrapper
        document.getElementById('landing-page').classList.add('active');
        document.getElementById('caseStudyWrapper').style.display = 'none';
        document.getElementById('navWrapper').classList.add('hidden');
        
        // Initialize hex portrait
        initHexPortrait();
        
        // Trigger landing page hex animation if hexagons exist
        if (landingHexagons && landingHexagons.length > 0) {
            triggerLandingAnimation();
        }
        
        // Update nav links
        document.querySelectorAll('.nav-link[data-case]').forEach(link => {
            link.classList.remove('active');
        });
        
        // Update URL hash
        history.replaceState(null, null, '#landing');
    }

    function initNavigation() {
        // Set up case study navigation
        document.querySelectorAll('.nav-link[data-case], .case-study-card[data-case]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                switchCaseStudy(link.dataset.case);
            });
        });
        
        // Set up profile link to go to landing
        document.getElementById('profileLink').addEventListener('click', (e) => {
            e.preventDefault();
            showLanding();
        });
        
        // Handle initial hash
        const hash = window.location.hash.slice(1);
        if (hash && caseStudyConfig[hash]) {
            // Initialize map first, then switch to case study
            setTimeout(() => switchCaseStudy(hash), 100);
        } else {
            // Show landing page
            showLanding();
        }
        
        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.slice(1);
            if (hash === 'landing' || !hash) {
                showLanding();
            } else if (caseStudyConfig[hash]) {
                switchCaseStudy(hash);
            }
        });
    }

    // ============================================================
    // INIT MAP (lazy - only when needed)
    // ============================================================
    async function initMap() {
        if (map) return; // Already initialized
        
        const mapContainer = document.getElementById('mapContainer');
        
        // Wait for layout
        await new Promise(r => requestAnimationFrame(r));
        
        // Size canvas
        canvas.width = mapContainer.clientWidth;
        canvas.height = mapContainer.clientHeight;
        
        // Init Leaflet
        map = L.map('map', {
            center: [55.0, -3.0],
            zoom: 6,
            zoomControl: false,
            dragging: false,
            touchZoom: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false,
            keyboard: false
        });

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap',
            maxZoom: 19
        }).addTo(map);

        map.invalidateSize();

        // Load boundaries
        geoJsonData = EMBEDDED_BOUNDARIES;
        await loadWorldwideData();
    }

    // ============================================================
    // INIT
    // ============================================================
    async function init() {
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        
        // Hide canvas initially until animation is ready
        canvas.style.opacity = '0';

        // Initialize navigation system first
        initNavigation();
        
        // Only initialize map if we're showing a case study (not landing page)
        if (!currentCaseStudy) {
            // We're on landing page, no need to init map
            return;
        }

        // Wait one frame for layout
        await new Promise(r => requestAnimationFrame(r));

        // Size map container from headline to end of result section
        const activeCase = document.querySelector('.case-study.active');
        const mapContainer = document.getElementById('mapContainer');
        if (activeCase) {
            const h1 = activeCase.querySelector('h1');
            const description = activeCase.querySelector('.description');
            if (h1 && description) {
                const h1Top = h1.getBoundingClientRect().top;
                const descBottom = description.getBoundingClientRect().bottom;
                const height = descBottom - h1Top;
                mapContainer.style.height = height + 'px';
            }
        }

        canvas.width = mapContainer.clientWidth;
        canvas.height = mapContainer.clientHeight;

        // Init Leaflet with view matching the active case study
        const initialCaseConfig = caseStudyConfig[currentCaseStudy] || caseStudyConfig['product-ownership'];
        map = L.map('map', {
            center: initialCaseConfig.center,
            zoom: initialCaseConfig.zoom,
            zoomControl: false,
            dragging: false,
            touchZoom: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false,
            keyboard: false
        });

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap',
            maxZoom: 19
        }).addTo(map);

        map.invalidateSize();

        // Load data then show map - content is already visible
        geoJsonData = EMBEDDED_BOUNDARIES;
        
        // Try to load worldwide data
        await loadWorldwideData();
        
        // Now show map (either with worldwide or embedded fallback)
        generateHexagons();
        canvas.style.opacity = '1';
        triggerAnimation();

        // ---- EVENT HANDLERS ----

        // Map pan/zoom: update debug views live, regenerate hexes on end
        map.on('move', () => {
            if (isResizing) return;
            if (debugMode === 2) drawBoundaries();
            else if (debugMode === 3) drawPointGrid();
            else if (debugMode === 4) drawHexagonsStatic();
        });

        map.on('moveend', () => {
            if (isResizing) return;
            if (debugMode === 0) { 
                canvas.style.opacity = '0';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                generateHexagons(); 
                canvas.style.opacity = '1';
                triggerAnimation(); 
            }
            else setDebugMode(debugMode);
        });

        map.on('zoomend', () => {
            if (isResizing) return;
            if (debugMode === 0) { 
                canvas.style.opacity = '0';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                generateHexagons(); 
                canvas.style.opacity = '1';
                triggerAnimation(); 
            }
            else setDebugMode(debugMode);
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gisModal').classList.contains('visible')) return;
            if (!currentCaseStudy) return; // Only enable on case study pages with maps

            // Keys 1-5 for debug modes (5 = animation/mode 0)
            if (e.key >= '1' && e.key <= '5') { 
                const mode = e.key === '5' ? 0 : parseInt(e.key);
                setDebugMode(mode); 
                e.preventDefault(); 
                return; 
            }
            
            // Key 'i' for GIS modal
            if (e.key.toLowerCase() === 'i') { 
                document.getElementById('gisModal').classList.add('visible'); 
                e.preventDefault(); 
                return; 
            }

            // WASD for map panning
            const c = map.getCenter(), z = map.getZoom(), p = 0.1;
            switch (e.key.toLowerCase()) {
                case 'w': map.setView([c.lat + p, c.lng]); e.preventDefault(); break;
                case 's': map.setView([c.lat - p, c.lng]); e.preventDefault(); break;
                case 'a': map.setView([c.lat, c.lng - p]); e.preventDefault(); break;
                case 'd': map.setView([c.lat, c.lng + p]); e.preventDefault(); break;
                case '+': case '=': map.setZoom(z + 1); e.preventDefault(); break;
                case '-': case '_': map.setZoom(z - 1); e.preventDefault(); break;
            }
        });

        // Nav hex hover â†’ keymap tooltip
        const tooltip = document.getElementById('keymapTooltip');
        canvas.addEventListener('mousemove', (e) => {
            if (!currentCaseStudy) return;
            const r = canvas.getBoundingClientRect();
            const x = e.clientX - r.left, y = e.clientY - r.top;
            if (window.navHex && worldwideLoaded && window.navHex.containsPoint(x, y)) {
                canvas.style.cursor = 'help';
                tooltip.classList.add('visible');
            } else {
                canvas.style.cursor = 'default';
                tooltip.classList.remove('visible');
            }
        });
        canvas.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));

        // Resize: hide canvas, debounce, recalc, show
        let resizeRAF = null;
        window.addEventListener('resize', () => {
            if (!currentCaseStudy) return; // Only handle resize on case study pages
            
            isResizing = true;
            if (resizeRAF) cancelAnimationFrame(resizeRAF);
            canvas.style.opacity = '0';
            clearTimeout(window._resizeTimeout);

            resizeRAF = requestAnimationFrame(() => {
                const activeCase = document.querySelector('.case-study.active');
                const mc = document.getElementById('mapContainer');
                if (activeCase && mc) {
                    const h1 = activeCase.querySelector('h1');
                    const description = activeCase.querySelector('.description');
                    if (h1 && description) {
                        const h1Top = h1.getBoundingClientRect().top;
                        const descBottom = description.getBoundingClientRect().bottom;
                        const height = descBottom - h1Top;
                        mc.style.height = height + 'px';
                    }
                    
                    // Resize canvas
                    canvas.width = mc.clientWidth;
                    canvas.height = mc.clientHeight;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    map.invalidateSize();

                    window._resizeTimeout = setTimeout(() => {
                        isResizing = false;
                        // CRITICAL: Actually regenerate hexagons after resize
                        if (debugMode === 0) { 
                            generateHexagons(); 
                            canvas.style.opacity = '1';
                            triggerAnimation(); 
                        } else {
                            setDebugMode(debugMode);
                            canvas.style.opacity = '1';
                        }
                    }, 300);
                }
            });
        });
    }

    function toggleDetails(caseStudyId) {
        // Handle both old single toggle and new multi-case study toggles
        if (caseStudyId) {
            const toggle = document.querySelector(`#${caseStudyId}DetailsContent`).previousElementSibling;
            const content = document.getElementById(`${caseStudyId}DetailsContent`);
            toggle.classList.toggle('open');
            content.classList.toggle('open');
        } else {
            // Legacy support for AWPR case study
            document.querySelector('.details-toggle').classList.toggle('open');
            document.getElementById('detailsContent').classList.toggle('open');
        }
    }

    // ============================================================
    // HEX PORTRAIT SYSTEM
    // ============================================================
    
    class HexPortrait {
        constructor(canvasId, options = {}) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.hexSize = options.hexSize || 10;
            this.targetHeight = options.targetHeight || 600;
            this.animationDuration = options.animationDuration || 560;
            this.rowDelay = options.rowDelay || 50;
            this.sampleRadius = options.sampleRadius || 6;
            this.alphaThreshold = options.alphaThreshold || 128;
            
            this.hexWidth = Math.sqrt(3) * this.hexSize;
            this.rowHeight = this.hexSize * 1.5;
            
            this.hexagons = [];
            this.imageData = null;
        }

        loadImage(imageSource) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                
                if (typeof imageSource === 'string') {
                    img.src = imageSource;
                } else if (imageSource instanceof File) {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(imageSource);
                    return;
                }
                
                img.onload = () => {
                    this.generateHexagons(img);
                    resolve();
                };
                
                img.onerror = () => reject(new Error('Failed to load image'));
            });
        }

        sampleImageColor(imgCanvas, imgCtx, x, y) {
            const imageX = Math.floor(x);
            const imageY = Math.floor(y);
            
            const startX = Math.max(0, imageX - this.sampleRadius);
            const startY = Math.max(0, imageY - this.sampleRadius);
            const endX = Math.min(imgCanvas.width, imageX + this.sampleRadius);
            const endY = Math.min(imgCanvas.height, imageY + this.sampleRadius);
            
            const sampleData = imgCtx.getImageData(startX, startY, endX - startX, endY - startY);
            
            let r = 0, g = 0, b = 0, alpha = 0, count = 0;
            
            for (let i = 0; i < sampleData.data.length; i += 4) {
                r += sampleData.data[i];
                g += sampleData.data[i + 1];
                b += sampleData.data[i + 2];
                alpha += sampleData.data[i + 3];
                count++;
            }
            
            if (count === 0) return null;
            
            const avgAlpha = alpha / count;
            if (avgAlpha < this.alphaThreshold) return null;
            
            r = Math.round(r / count);
            g = Math.round(g / count);
            b = Math.round(b / count);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        generateHexagons(img) {
            const imgCanvas = document.createElement('canvas');
            const imgCtx = imgCanvas.getContext('2d');
            
            const targetWidth = Math.floor(this.targetHeight * (img.width / img.height));
            
            this.canvas.width = targetWidth;
            this.canvas.height = this.targetHeight;
            
            imgCanvas.width = targetWidth;
            imgCanvas.height = this.targetHeight;
            imgCtx.drawImage(img, 0, 0, targetWidth, this.targetHeight);
            
            this.imageData = { img: imgCanvas, ctx: imgCtx };
            this.hexagons = [];
            
            let rowIndex = 0;
            
            for (let y = this.hexSize; y <= this.canvas.height - this.hexSize; y += this.rowHeight) {
                const xOffset = (rowIndex % 2) * (this.hexWidth / 2);
                
                for (let x = this.hexSize + xOffset; x <= this.canvas.width - this.hexSize; x += this.hexWidth) {
                    const color = this.sampleImageColor(imgCanvas, imgCtx, x, y);
                    if (color !== null) {
                        this.hexagons.push(new HexagonPortrait(
                            x, y, this.hexSize, rowIndex, color, 
                            this.animationDuration, this.rowDelay
                        ));
                    }
                }
                
                rowIndex++;
            }
        }

        animate(timestamp) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            let allDone = true;
            for (const hex of this.hexagons) {
                hex.startAnimation(timestamp);
                if (!hex.update(timestamp)) allDone = false;
                hex.draw(this.ctx);
            }

            if (!allDone) {
                requestAnimationFrame((ts) => this.animate(ts));
            }
        }

        play() {
            this.hexagons.forEach(h => { 
                h.startTime = null; 
                h.rotation = 90; 
                h.opacity = 0; 
            });
            requestAnimationFrame((ts) => this.animate(ts));
        }
    }

    class HexagonPortrait {
        constructor(x, y, size, row, color, duration, rowDelay) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.row = row;
            this.color = color;
            this.rotation = 90;
            this.opacity = 0;
            this.animationDelay = row * rowDelay;
            this.duration = duration;
            this.startTime = null;
        }

        getPoints() {
            const pts = [];
            for (let i = 0; i < 6; i++) {
                const a = Math.PI / 3 * i - Math.PI / 6;
                pts.push([
                    this.x + this.size * Math.cos(a),
                    this.y + this.size * Math.sin(a)
                ]);
            }
            return pts;
        }

        startAnimation(now) {
            if (!this.startTime) this.startTime = now + this.animationDelay;
        }

        update(now) {
            if (!this.startTime || now < this.startTime) return false;
            const elapsed = now - this.startTime;
            const progress = Math.min(elapsed / this.duration, 1);
            const easeOut = 1 - Math.pow(1 - progress, 3);

            this.rotation = 90 - (90 * easeOut);
            if (progress > 0.6) {
                const bp = (progress - 0.6) / 0.4;
                this.rotation -= Math.sin(bp * Math.PI) * 8;
            }
            this.opacity = easeOut;
            return progress >= 1;
        }

        draw(ctx) {
            ctx.save();

            const scaleY = Math.cos(this.rotation * Math.PI / 180);
            ctx.translate(this.x, this.y);
            ctx.scale(1, scaleY);
            ctx.translate(-this.x, -this.y);
            ctx.globalAlpha = this.opacity;

            const pts = this.getPoints();
            const buf = 1.5;
            ctx.fillStyle = this.color;

            ctx.beginPath();
            ctx.moveTo(
                this.x + (pts[0][0] - this.x) * (1 - buf / this.size),
                this.y + (pts[0][1] - this.y) * (1 - buf / this.size)
            );
            for (let i = 1; i < pts.length; i++) {
                ctx.lineTo(
                    this.x + (pts[i][0] - this.x) * (1 - buf / this.size),
                    this.y + (pts[i][1] - this.y) * (1 - buf / this.size)
                );
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }

    // Initialize hex portrait when landing page is shown
    let hexPortrait = null;
    
    function initHexPortrait() {
        if (!hexPortrait) {
            hexPortrait = new HexPortrait('landingPortrait', {
                hexSize: 10,
                targetHeight: 600
            });
            
            hexPortrait.loadImage('jurgen-portrait-cropped.png')
                .then(() => hexPortrait.play())
                .catch(err => console.error('Failed to load portrait:', err));
        }
    }

    window.addEventListener('load', () => {
        init();
        // Init immediately - requestAnimationFrame inside handles timing
        initLandingPortrait();
    });
    
    // ============================================================
    // LANDING PORTRAIT HEX ANIMATION (based on working hex-portrait.html)
    // ============================================================
    
    class LandingHexagon {
        constructor(x, y, size, row, color) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.row = row;
            this.color = color;
            this.rotation = 90;
            this.opacity = 0;
            this.animationDelay = row * 50;
            this.startTime = null;
        }

        getPoints() {
            const pts = [];
            for (let i = 0; i < 6; i++) {
                const a = Math.PI / 3 * i - Math.PI / 6;
                pts.push([
                    this.x + this.size * Math.cos(a),
                    this.y + this.size * Math.sin(a)
                ]);
            }
            return pts;
        }

        startAnimation(now) {
            if (!this.startTime) this.startTime = now + this.animationDelay;
        }

        update(now) {
            if (!this.startTime || now < this.startTime) return false;
            const elapsed = now - this.startTime;
            const duration = 560;
            const progress = Math.min(elapsed / duration, 1);
            const easeOut = 1 - Math.pow(1 - progress, 3);

            this.rotation = 90 - (90 * easeOut);
            if (progress > 0.6) {
                const bp = (progress - 0.6) / 0.4;
                this.rotation -= Math.sin(bp * Math.PI) * 8;
            }
            this.opacity = easeOut;
            return progress >= 1;
        }

        draw(ctx) {
            ctx.save();

            const scaleY = Math.cos(this.rotation * Math.PI / 180);
            ctx.translate(this.x, this.y);
            ctx.scale(1, scaleY);
            ctx.translate(-this.x, -this.y);
            ctx.globalAlpha = this.opacity;

            const pts = this.getPoints();
            const buf = 1.5;
            ctx.fillStyle = this.color;

            ctx.beginPath();
            ctx.moveTo(
                this.x + (pts[0][0] - this.x) * (1 - buf / this.size),
                this.y + (pts[0][1] - this.y) * (1 - buf / this.size)
            );
            for (let i = 1; i < pts.length; i++) {
                ctx.lineTo(
                    this.x + (pts[i][0] - this.x) * (1 - buf / this.size),
                    this.y + (pts[i][1] - this.y) * (1 - buf / this.size)
                );
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }

    let landingHexagons = [];
    let landingCanvas = null;
    let landingCtx = null;

    function sampleImageColor(imgCanvas, imgCtx, x, y, sampleRadius = 6) {
        const imageX = Math.floor(x);
        const imageY = Math.floor(y);
        
        const startX = Math.max(0, imageX - sampleRadius);
        const startY = Math.max(0, imageY - sampleRadius);
        const endX = Math.min(imgCanvas.width, imageX + sampleRadius);
        const endY = Math.min(imgCanvas.height, imageY + sampleRadius);
        
        const sampleData = imgCtx.getImageData(startX, startY, endX - startX, endY - startY);
        
        let r = 0, g = 0, b = 0, alpha = 0, count = 0;
        
        for (let i = 0; i < sampleData.data.length; i += 4) {
            r += sampleData.data[i];
            g += sampleData.data[i + 1];
            b += sampleData.data[i + 2];
            alpha += sampleData.data[i + 3];
            count++;
        }
        
        if (count === 0) return null;
        
        const avgAlpha = alpha / count;
        if (avgAlpha < 128) return null;
        
        r = Math.round(r / count);
        g = Math.round(g / count);
        b = Math.round(b / count);
        
        return `rgb(${r}, ${g}, ${b})`;
    }

    function generateLandingHexagons(img) {
        console.log('Generating landing hexagons from image');
        
        // Create offscreen canvas for color sampling
        const imgCanvas = document.createElement('canvas');
        const imgCtx = imgCanvas.getContext('2d');
        
        // Use the already-set canvas size (don't resize to prevent jitter)
        const size = landingCanvas.width;
        
        console.log('Canvas size:', size, 'x', size);
        
        // Size offscreen canvas to match
        imgCanvas.width = size;
        imgCanvas.height = size;
        
        // Calculate crop to center face (35% from top)
        const aspectRatio = img.width / img.height;
        let sourceX, sourceY, sourceWidth, sourceHeight;
        
        if (aspectRatio > 1) {
            sourceWidth = img.height;
            sourceHeight = img.height;
            sourceX = (img.width - img.height) / 2;
            sourceY = 0;
        } else {
            sourceWidth = img.width;
            sourceHeight = img.width;
            sourceX = 0;
            sourceY = img.height * 0.35 - sourceWidth / 2;
            sourceY = Math.max(0, Math.min(sourceY, img.height - sourceHeight));
        }
        
        console.log('Drawing image to offscreen canvas, crop:', sourceX, sourceY, sourceWidth, sourceHeight);
        
        // Draw image to OFFSCREEN canvas only
        imgCtx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, size, size);
        
        // Generate hexagons by sampling from offscreen canvas
        landingHexagons = [];
        
        const hexSize = 12;
        const hexWidth = Math.sqrt(3) * hexSize;
        const rowHeight = hexSize * 1.5;
        
        let rowIndex = 0;
        
        for (let y = hexSize; y <= size - hexSize; y += rowHeight) {
            const xOffset = (rowIndex % 2) * (hexWidth / 2);
            
            for (let x = hexSize + xOffset; x <= size - hexSize; x += hexWidth) {
                const color = sampleImageColor(imgCanvas, imgCtx, x, y, 6);
                if (color !== null) {
                    landingHexagons.push(new LandingHexagon(x, y, hexSize, rowIndex, color));
                }
            }
            
            rowIndex++;
        }
        
        console.log('Generated', landingHexagons.length, 'hexagons');
    }

    function animateLandingHexagons(now) {
        // Verify canvas hasn't been resized unexpectedly
        if (landingCanvas.dataset.lockedSize) {
            const expectedSize = parseInt(landingCanvas.dataset.lockedSize);
            if (landingCanvas.width !== expectedSize || landingCanvas.height !== expectedSize) {
                console.warn('Canvas size changed unexpectedly!', 
                    'Expected:', expectedSize, 
                    'Got:', landingCanvas.width, 'x', landingCanvas.height);
            }
        }
        
        landingCtx.clearRect(0, 0, landingCanvas.width, landingCanvas.height);

        let allDone = true;
        for (const hex of landingHexagons) {
            hex.startAnimation(now);
            if (!hex.update(now)) allDone = false;
            hex.draw(landingCtx);
        }

        if (!allDone) {
            requestAnimationFrame(animateLandingHexagons);
        } else {
            console.log('Animation complete. Final canvas size:', landingCanvas.width, 'x', landingCanvas.height);
        }
    }

    function triggerLandingAnimation() {
        console.log('Triggering landing hexagon animation');
        // Clear canvas before animation starts to prevent any ghost
        landingCtx.clearRect(0, 0, landingCanvas.width, landingCanvas.height);
        landingHexagons.forEach(h => { h.startTime = null; h.rotation = 90; h.opacity = 0; });
        requestAnimationFrame(animateLandingHexagons);
    }

    function initLandingPortrait() {
        landingCanvas = document.getElementById('landingPortrait');
        if (!landingCanvas) {
            console.log('Landing portrait canvas not found');
            return;
        }
        
        console.log('Initializing landing portrait hex animation');
        
        landingCtx = landingCanvas.getContext('2d');
        
        // Clear immediately to prevent any flash
        const tempSize = landingCanvas.clientWidth;
        landingCanvas.width = tempSize;
        landingCanvas.height = tempSize;
        landingCtx.clearRect(0, 0, tempSize, tempSize);
        
        // Load image first, THEN size canvas based on final image load timing
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = 'jurgen-portrait-cropped.png';
        
        img.onerror = () => {
            console.error('Failed to load portrait image:', img.src);
        };
        
        img.onload = () => {
            console.log('Portrait image loaded');
            
            // NOW get the final size after everything has settled
            requestAnimationFrame(() => {
                const rect = landingCanvas.getBoundingClientRect();
                const finalSize = Math.floor(rect.width);
                
                console.log('Final canvas size:', finalSize, 'x', finalSize);
                
                // Set internal dimensions
                landingCanvas.width = finalSize;
                landingCanvas.height = finalSize;
                
                // Lock CSS dimensions completely
                landingCanvas.style.width = finalSize + 'px';
                landingCanvas.style.height = finalSize + 'px';
                landingCanvas.style.minWidth = finalSize + 'px';
                landingCanvas.style.minHeight = finalSize + 'px';
                landingCanvas.style.maxWidth = finalSize + 'px';
                landingCanvas.style.maxHeight = finalSize + 'px';
                
                // Clear
                landingCtx.clearRect(0, 0, finalSize, finalSize);
                
                // Generate hexagons and animate
                landingCanvas.dataset.lockedSize = finalSize;
                generateLandingHexagons(img);
                triggerLandingAnimation();
            });
        };
    }
    
    // Touch/click handlers for keymap keys
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.keymap-key[data-key]').forEach(key => {
            const handler = (e) => {
                if (!currentCaseStudy) return; // Disable on landing page
                
                e.preventDefault();
                e.stopPropagation();
                const keyValue = key.getAttribute('data-key');
                
                // Simulate keyboard event
                const keyEvent = new KeyboardEvent('keydown', {
                    key: keyValue,
                    code: 'Digit' + keyValue,
                    keyCode: 48 + parseInt(keyValue),
                    which: 48 + parseInt(keyValue),
                    bubbles: true
                });
                document.dispatchEvent(keyEvent);
                
                // Visual feedback
                key.style.transform = 'translateY(0)';
                setTimeout(() => {
                    key.style.transform = '';
                }, 100);
            };
            
            key.addEventListener('click', handler);
            key.addEventListener('touchend', handler);
        });
    });
    </script>
</body>
</html>
